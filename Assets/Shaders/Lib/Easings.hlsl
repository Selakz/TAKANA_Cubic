#ifndef EASING_FUNCTIONS_HLSL
#define EASING_FUNCTIONS_HLSL

// Generated by LLM
static const float PI = 3.14159265358979323846f;

// Linear
float EaseLinear(float left, float right, float t)
{
    return lerp(left, right, t);
}

// Still (constant)
float EaseStill(float left, float right, float t)
{
    if (t > 1.0f - 1e-6f) return right;
    return left;
}

// Sine
float EaseInSine(float left, float right, float t)
{
    return left + (right - left) * (1.0f - cos(t * PI * 0.5f));
}

float EaseOutSine(float left, float right, float t)
{
    return left + (right - left) * sin(t * PI * 0.5f);
}

float EaseInOutSine(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f;
        return left + (right - left) * 0.5f * (1.0f - cos(tt * PI * 0.5f));
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f;
        return left + (right - left) * (0.5f + 0.5f * sin(tt * PI * 0.5f));
    }
}

float EaseOutInSine(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f;
        return left + (right - left) * 0.5f * sin(tt * PI * 0.5f);
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f;
        return left + (right - left) * (1.0f - 0.5f * cos(tt * PI * 0.5f));
    }
}

// Quad
float EaseInQuad(float left, float right, float t)
{
    return left + (right - left) * t * t;
}

float EaseOutQuad(float left, float right, float t)
{
    return left + (right - left) * (1.0f - (1.0f - t) * (1.0f - t));
}

float EaseInOutQuad(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f;
        return left + (right - left) * 0.5f * tt * tt;
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f;
        return left + (right - left) * (1.0f - 0.5f * (1.0f - tt) * (1.0f - tt));
    }
}

float EaseOutInQuad(float left, float right, float t)
{
    return t < 0.5f
               ? EaseOutQuad(left, (left + right) / 2.0f, t * 2.0f)
               : EaseInQuad((left + right) / 2.0f, right, (t - 0.5f) * 2.0f);
}

// Cubic
float EaseInCubic(float left, float right, float t)
{
    return left + (right - left) * t * t * t;
}

float EaseOutCubic(float left, float right, float t)
{
    float invT = 1.0f - t;
    return left + (right - left) * (1.0f - invT * invT * invT);
}

float EaseInOutCubic(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f;
        return left + (right - left) * 0.5f * tt * tt * tt;
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f;
        float invT = 1.0f - tt;
        return left + (right - left) * (1.0f - 0.5f * invT * invT * invT);
    }
}

float EaseOutInCubic(float left, float right, float t)
{
    return t < 0.5f
               ? EaseOutCubic(left, (left + right) / 2.0f, t * 2.0f)
               : EaseInCubic((left + right) / 2.0f, right, (t - 0.5f) * 2.0f);
}

// Quart (Quartic)
float EaseInQuart(float left, float right, float t)
{
    float tt = t * t;
    float tttt = tt * tt;
    return left + (right - left) * tttt;
}

float EaseOutQuart(float left, float right, float t)
{
    float invT = 1.0f - t;
    float invTT = invT * invT;
    float invTTTT = invTT * invTT;
    return left + (right - left) * (1.0f - invTTTT);
}

float EaseInOutQuart(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f;
        float tttt = tt * tt * tt * tt;
        return left + (right - left) * 0.5f * tttt;
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f;
        float invT = 1.0f - tt;
        float invTT = invT * invT;
        float invTTTT = invTT * invTT;
        return left + (right - left) * (1.0f - 0.5f * invTTTT);
    }
}

float EaseOutInQuart(float left, float right, float t)
{
    return t < 0.5f
               ? EaseOutQuart(left, (left + right) / 2.0f, t * 2.0f)
               : EaseInQuart((left + right) / 2.0f, right, (t - 0.5f) * 2.0f);
}

// Quint (Quintic)
float EaseInQuint(float left, float right, float t)
{
    float tt = t * t;
    float ttttt = tt * tt * t; // t^5
    return left + (right - left) * ttttt;
}

float EaseOutQuint(float left, float right, float t)
{
    float invT = 1.0f - t;
    float invTT = invT * invT;
    float invTTTTT = invTT * invTT * invT; // (1-t)^5
    return left + (right - left) * (1.0f - invTTTTT);
}

float EaseInOutQuint(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f;
        float t5 = tt * tt * tt * tt * tt;
        return left + (right - left) * 0.5f * t5;
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f;
        float invT = 1.0f - tt;
        float invT5 = invT * invT * invT * invT * invT;
        return left + (right - left) * (1.0f - 0.5f * invT5);
    }
}

float EaseOutInQuint(float left, float right, float t)
{
    return t < 0.5f
               ? EaseOutQuint(left, (left + right) / 2.0f, t * 2.0f)
               : EaseInQuint((left + right) / 2.0f, right, (t - 0.5f) * 2.0f);
}

// Expo (Exponential)
float EaseInExpo(float left, float right, float t)
{
    // Handle t == 0 to avoid pow(2, -10) when not needed; but in practice, use epsilon
    float factor = t < 1e-5f ? 0.0f : pow(2.0f, 10.0f * (t - 1.0f));
    return left + (right - left) * factor;
}

float EaseOutExpo(float left, float right, float t)
{
    // Handle t == 1
    float factor = t > 1.0f - 1e-5f ? 1.0f : 1.0f - pow(2.0f, -10.0f * t);
    return left + (right - left) * factor;
}

float EaseInOutExpo(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f;
        float factor = tt < 1e-5f ? 0.0f : pow(2.0f, 10.0f * (tt - 1.0f));
        return left + (right - left) * 0.5f * factor;
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f;
        float factor = tt > 1.0f - 1e-5f ? 1.0f : 1.0f - pow(2.0f, -10.0f * tt);
        return left + (right - left) * (0.5f + 0.5f * factor);
    }
}

float EaseOutInExpo(float left, float right, float t)
{
    return t < 0.5f
               ? EaseOutExpo(left, (left + right) / 2.0f, t * 2.0f)
               : EaseInExpo((left + right) / 2.0f, right, (t - 0.5f) * 2.0f);
}

// Circ (Circular)
float EaseInCirc(float left, float right, float t)
{
    return left + (right - left) * (1.0f - sqrt(1.0f - t * t));
}

float EaseOutCirc(float left, float right, float t)
{
    float tt = t - 1.0f;
    return left + (right - left) * sqrt(1.0f - tt * tt);
}

float EaseInOutCirc(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f;
        return left + (right - left) * 0.5f * (1.0f - sqrt(1.0f - tt * tt));
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f - 1.0f; // = 2t - 2
        return left + (right - left) * (0.5f + 0.5f * sqrt(1.0f - tt * tt));
    }
}

float EaseOutInCirc(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f - 1.0f;
        return left + (right - left) * 0.5f * sqrt(1.0f - tt * tt);
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f;
        return left + (right - left) * (0.5f + 0.5f * (1.0f - sqrt(1.0f - tt * tt)));
    }
}

// Back
static const float BACK_OVERSHOOT = 1.70158f;

float EaseInBack(float left, float right, float t)
{
    float c3 = BACK_OVERSHOOT + 1.0f;
    return left + (right - left) * (c3 * t * t * t - BACK_OVERSHOOT * t * t);
}

float EaseOutBack(float left, float right, float t)
{
    float c3 = BACK_OVERSHOOT + 1.0f;
    float tt = t - 1.0f;
    return left + (right - left) * (1.0f + c3 * tt * tt * tt + BACK_OVERSHOOT * tt * tt);
}

float EaseInOutBack(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f;
        float c3 = BACK_OVERSHOOT + 1.0f;
        float val = c3 * tt * tt * tt - BACK_OVERSHOOT * tt * tt;
        return left + (right - left) * 0.5f * val;
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f - 1.0f; // = 2t - 2
        float c3 = BACK_OVERSHOOT + 1.0f;
        float val = 1.0f + c3 * tt * tt * tt + BACK_OVERSHOOT * tt * tt;
        return left + (right - left) * (0.5f + 0.5f * val);
    }
}

float EaseOutInBack(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f - 1.0f;
        float c3 = BACK_OVERSHOOT + 1.0f;
        float val = 1.0f + c3 * tt * tt * tt + BACK_OVERSHOOT * tt * tt;
        return left + (right - left) * 0.5f * val;
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f;
        float c3 = BACK_OVERSHOOT + 1.0f;
        float val = c3 * tt * tt * tt - BACK_OVERSHOOT * tt * tt;
        return left + (right - left) * (0.5f + 0.5f * val);
    }
}

// Elastic
static const float ELASTIC_C4 = 2.0f * 3.14159265358979323846f / 3.0f; // 2дл/3

float EaseInElastic(float left, float right, float t)
{
    if (t < 1e-5f)
        return left;
    if (t > 1.0f - 1e-5f)
        return right;

    float exponent = 10.0f * t - 10.0f;
    float sinArg = (10.0f * t - 10.75f) * ELASTIC_C4;
    float factor = -pow(2.0f, exponent) * sin(sinArg);
    return left + (right - left) * factor;
}

float EaseOutElastic(float left, float right, float t)
{
    if (t < 1e-5f)
        return left;
    if (t > 1.0f - 1e-5f)
        return right;

    float exponent = -10.0f * t;
    float sinArg = (10.0f * t - 0.75f) * ELASTIC_C4;
    float factor = pow(2.0f, exponent) * sin(sinArg) + 1.0f;
    return left + (right - left) * factor;
}

float EaseInOutElastic(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f;
        if (tt < 1e-5f)
            return left;
        if (tt > 1.0f - 1e-5f)
            return lerp(left, right, 0.5f);

        float exponent = 10.0f * tt - 10.0f;
        float sinArg = (10.0f * tt - 10.75f) * ELASTIC_C4;
        float factor = -pow(2.0f, exponent) * sin(sinArg);
        return left + (right - left) * 0.5f * factor;
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f;
        if (tt < 1e-5f)
            return lerp(left, right, 0.5f);
        if (tt > 1.0f - 1e-5f)
            return right;

        float exponent = -10.0f * tt;
        float sinArg = (10.0f * tt - 0.75f) * ELASTIC_C4;
        float factor = pow(2.0f, exponent) * sin(sinArg) + 1.0f;
        return left + (right - left) * (0.5f + 0.5f * factor);
    }
}

float EaseOutInElastic(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f;
        if (tt < 1e-5f)
            return left;
        if (tt > 1.0f - 1e-5f)
            return lerp(left, right, 0.5f);

        float exponent = -10.0f * tt;
        float sinArg = (10.0f * tt - 0.75f) * ELASTIC_C4;
        float factor = pow(2.0f, exponent) * sin(sinArg) + 1.0f;
        return left + (right - left) * 0.5f * factor;
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f;
        if (tt < 1e-5f)
            return lerp(left, right, 0.5f);
        if (tt > 1.0f - 1e-5f)
            return right;

        float exponent = 10.0f * tt - 10.0f;
        float sinArg = (10.0f * tt - 10.75f) * ELASTIC_C4;
        float factor = -pow(2.0f, exponent) * sin(sinArg);
        return left + (right - left) * (0.5f + 0.5f * factor);
    }
}

// Bounce
float EaseOutBounce(float left, float right, float t)
{
    const float n1 = 7.5625f;
    const float d1 = 2.75f;

    float val;
    if (t < 1.0f / d1)
    {
        val = n1 * t * t;
    }
    else if (t < 2.0f / d1)
    {
        t -= 1.5f / d1;
        val = n1 * t * t + 0.75f;
    }
    else if (t < 2.5f / d1)
    {
        t -= 2.25f / d1;
        val = n1 * t * t + 0.9375f;
    }
    else
    {
        t -= 2.625f / d1;
        val = n1 * t * t + 0.984375f;
    }
    return left + (right - left) * val;
}

float EaseInBounce(float left, float right, float t)
{
    // In = 1 - Out(1 - t)
    float outVal = EaseOutBounce(0.0f, 1.0f, 1.0f - t);
    return left + (right - left) * (1.0f - outVal);
}

float EaseInOutBounce(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f;
        float inVal = EaseInBounce(0.0f, 1.0f, tt);
        return left + (right - left) * 0.5f * inVal;
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f;
        float outVal = EaseOutBounce(0.0f, 1.0f, tt);
        return left + (right - left) * (0.5f + 0.5f * outVal);
    }
}

float EaseOutInBounce(float left, float right, float t)
{
    if (t < 0.5f)
    {
        float tt = t * 2.0f;
        float outVal = EaseOutBounce(0.0f, 1.0f, tt);
        return left + (right - left) * 0.5f * outVal;
    }
    else
    {
        float tt = (t - 0.5f) * 2.0f;
        float inVal = EaseInBounce(0.0f, 1.0f, tt);
        return left + (right - left) * (0.5f + 0.5f * inVal);
    }
}

float EaseById(float left, float right, float t, int id)
{
    switch (id)
    {
    case 0:
        return EaseStill(left, right, t);
    case 1:
        return EaseLinear(left, right, t);
    case 12:
        return EaseInSine(left, right, t);
    case 13:
        return EaseOutSine(left, right, t);
    case 14:
        return EaseInOutSine(left, right, t);
    case 15:
        return EaseOutInSine(left, right, t);
    case 22:
        return EaseInQuad(left, right, t);
    case 23:
        return EaseOutQuad(left, right, t);
    case 24:
        return EaseInOutQuad(left, right, t);
    case 25:
        return EaseOutInQuad(left, right, t);
    case 32:
        return EaseInCubic(left, right, t);
    case 33:
        return EaseOutCubic(left, right, t);
    case 34:
        return EaseInOutCubic(left, right, t);
    case 35:
        return EaseOutInCubic(left, right, t);
    case 42:
        return EaseInQuart(left, right, t);
    case 43:
        return EaseOutQuart(left, right, t);
    case 44:
        return EaseInOutQuart(left, right, t);
    case 45:
        return EaseOutInQuart(left, right, t);
    case 52:
        return EaseInQuint(left, right, t);
    case 53:
        return EaseOutQuint(left, right, t);
    case 54:
        return EaseInOutQuint(left, right, t);
    case 55:
        return EaseOutInQuint(left, right, t);
    case 62:
        return EaseInExpo(left, right, t);
    case 63:
        return EaseOutExpo(left, right, t);
    case 64:
        return EaseInOutExpo(left, right, t);
    case 65:
        return EaseOutInExpo(left, right, t);
    case 72:
        return EaseInCirc(left, right, t);
    case 73:
        return EaseOutCirc(left, right, t);
    case 74:
        return EaseInOutCirc(left, right, t);
    case 75:
        return EaseOutInCirc(left, right, t);
    case 82:
        return EaseInBack(left, right, t);
    case 83:
        return EaseOutBack(left, right, t);
    case 84:
        return EaseInOutBack(left, right, t);
    case 85:
        return EaseOutInBack(left, right, t);
    case 92:
        return EaseInElastic(left, right, t);
    case 93:
        return EaseOutElastic(left, right, t);
    case 94:
        return EaseInOutElastic(left, right, t);
    case 95:
        return EaseOutInElastic(left, right, t);
    case 2:
        return EaseInBounce(left, right, t);
    case 3:
        return EaseOutBounce(left, right, t);
    case 4:
        return EaseInOutBounce(left, right, t);
    case 5:
        return EaseOutInBounce(left, right, t);
    default:
        return EaseStill(left, right, t);
    }
}

float2 LineIntersection(float2 dir1, float2 pt1, float2 dir2, float2 pt2)
{
    float2 d1 = normalize(dir1);
    float2 d2 = normalize(dir2);

    float2 r = pt2 - pt1;

    float cross_d1_d2 = d1.x * d2.y - d1.y * d2.x;

    if (abs(cross_d1_d2) < 1e-5f) return pt2;

    float t = (r.x * d2.y - r.y * d2.x) / cross_d1_d2;

    return pt1 + t * d1;
}

#endif // EASING_FUNCTIONS_HLSL
